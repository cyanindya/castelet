# The main displayed node of this framework.
#
# This node goes through a script's syntax tree generated by the parser,
# and updates the stage and GUI nodes accordingly. This node is akin to
# a movie player, although it is intended only for a single scene/script file.
# This node only needs to play the script based on the syntax tree, and has no
# need to know where it is currently at.
# 
# Management of all of the scenes, however, should be done in other node.
# 
# To properly play/pause/stop the scene, use the following functions:
# - play(from_beginning) - start or resume the scene
# - pause() - makes sure _next() won't be triggered while pause is active
# - stop() - stops the scene playback and reset to the beginning
# - end() - terminates this node.

extends SubViewportContainer

const Tokenizer = preload("res://castelet/castelet_core/parser/castelet_tokenizer.gd")

var _tree : CasteletSyntaxTree
var _paused = false
var DialogueTools = load("res://castelet/castelet_core/dialogue_processing_tools.gd")
var dialogue_tools
var _timer : Timer
var _can_play := false
var _script_id := ""

var _thread : Thread
var _mutex : Mutex
var _semaphore : Semaphore
var _ending_thread = false

@onready var _game_manager : CasteletGameManager = get_node("/root/CasteletGameManager")
@onready var _state_manager : CasteletStateManager = get_node("/root/CasteletStateManager")
@onready var _assets_manager : CasteletAssetsManager = get_node("/root/CasteletAssetsManager")
@onready var _audio_manager : CasteletAudioManager = get_node("/root/CasteletAudioManager")
@onready var _transition_manager : CasteletTransitionManager = get_node("/root/CasteletTransitionManager")
@onready var _viewport_manager : CasteletViewportManager = get_node("/root/CasteletViewportManager")
@onready var _config_manager : CasteletConfigManager = get_node("/root/CasteletConfigManager")

@export var script_to_play : String:
	set(value):
		if value != "":
			load_script(value)
			await load_script_finished
			play_scene()
			
			await end_of_script
			end()


signal load_script_finished
signal end_of_script


# There is always chance that this function gets executed
# early before the nodes are even ready, potentially resulting
# in lack of script data. As such, multithreading is used to
# ensure the script data retrieval doesn't block the main thread,
# while also ensuring the script will be executed properly later.
func load_script(script_id : String):
	if _mutex == null:
		_mutex = Mutex.new()
	if _semaphore == null:
		_semaphore = Semaphore.new()
	
	_mutex.lock()
	_script_id = script_id
	_mutex.unlock()

	if _thread == null:
		_thread = Thread.new()
	if not _thread.is_started():
		_thread.start(_load_script_subprocess)
	
	_semaphore.post()

	await load_script_finished


func _load_script_subprocess():
	while true:
		
		_semaphore.wait()

		if _ending_thread == true:
			break

		_mutex.lock()
		while not _can_play:
			pass
		self._tree = _game_manager.script_trees[_script_id]
		load_script_finished.emit.call_deferred()
		_mutex.unlock()


func _ready():
	if _mutex == null:
		_mutex = Mutex.new()
	if _semaphore == null:
		_semaphore = Semaphore.new()
	if _thread == null:
		_thread = Thread.new()
	
	_timer = Timer.new()
	_timer.wait_time = 0.1
	add_child(_timer)
	
	_viewport_manager.viewport_resized.connect(func():
		if _viewport_manager.enable_window_content_resize:
			$SubViewport.size = Vector2i(_viewport_manager.base_viewport_width as int,
				_viewport_manager.base_viewport_height as int)	
	)
	$SubViewport.size = get_window().content_scale_size
	_transition_manager.vp = $SubViewport
	
	dialogue_tools = DialogueTools.new()
	
	# Connect the required signals to relevant callback functions
	end_of_script.connect(_on_end_of_script)
	_game_manager.progress.connect(_on_progress)

	await _state_manager.persistent_load_finish
	_can_play = true


func _next():

	# Preview the next expression on the tree before
	# actually grabbing them
	var next = self._tree.peek()

	# If end of script is reached, terminate.
	if self._tree.is_at_end():
		emit_signal("end_of_script")
		return
	
	# Perform different tasks based on the detected
	# expressions.
	if next is CasteletSyntaxTree.StageCommandExpression:
		if next.type in [Tokenizer.KEYWORDS.SCENE, Tokenizer.KEYWORDS.SHOW]:
			_update_stage_prop(_transition_manager.object_transition_data)
		elif next.type == Tokenizer.KEYWORDS.HIDE:
			_hide_stage_prop(_transition_manager.object_transition_data)
		elif next.type in [Tokenizer.KEYWORDS.BGM, Tokenizer.KEYWORDS.SFX]:
			_update_audio_channel()
		elif next.type == Tokenizer.KEYWORDS.VOICE:
			pass
		elif next.type == Tokenizer.KEYWORDS.TRANSITION:
			_update_transition()
		elif next.type == Tokenizer.KEYWORDS.WINDOW:
			_update_window()
		else:
			pass
	
	elif next is CasteletSyntaxTree.LabelExpression:
		self._tree.next()
		_game_manager.progress.emit()
	
	elif next is CasteletSyntaxTree.JumptoExpression:

		# If it's call function, append the call source to the stack
		if next is CasteletSyntaxTree.CallsubExpression:
			_game_manager.append_callsub_stack(self._tree.name, self._tree.get_index())

		if next.value in _game_manager.script_trees.keys():
			self.load_script(next.value)
			await load_script_finished
			self._tree.reset()
		else:
			if _game_manager.jump_checkpoints_list[next.value]["tree"] != self._tree.name:
				self.load_script(_game_manager.jump_checkpoints_list[next.value]["tree"])
				await load_script_finished
			self._tree.set_index(_game_manager.jump_checkpoints_list[next.value]["index"])
	
		_game_manager.progress.emit()
	
	elif next is CasteletSyntaxTree.ReturnExpression:
		if _game_manager.get_context_level() > 0:
			var origin = _game_manager.pop_callsub_stack()
			self.load_script(origin["tree"])
			await load_script_finished
			self._tree.set_index(origin["index"] + 1)
			_game_manager.progress.emit()
		# TODO: terminate the script
		else:
			end_of_script.emit()

	elif next is CasteletSyntaxTree.LoopBackExpression:
		self._tree = next.value
		self._tree.reset()
		_game_manager.progress.emit()
		
	elif next is CasteletSyntaxTree.FunctionCallExpression:
		var caller_object = self
		var func_name = ""
		var args = []
		
		var fnc = self._tree.next()
		var fnc_name = fnc.func_name.split(".")
		if len(fnc_name) > 1:
			caller_object = get_node("/root/" + fnc_name[0])
			func_name = fnc_name[-1]
		else:
			func_name = fnc_name[-1]
		
		for arg_tree in fnc.vals:
			args.append(_translate_expression(arg_tree))
		
		var func_callable = Callable(caller_object, func_name)
		func_callable.callv(args)

		_game_manager.progress.emit()
	
	elif next is CasteletSyntaxTree.IfElseExpression:
		var if_else_block = self._tree.next()

		# Evaluate each condition, then transfer the execution to each
		# condition's associated subroutines
		for condition in if_else_block.value:
			var eval = _translate_expression(condition.evaluator)
			if eval == true:
				# self._tree = _game_manager.script_trees[condition.subroutine]
				self.load_script(condition.subroutine)
				await load_script_finished
				self._tree.reset()
				break
		
		_game_manager.progress.emit()

	elif next is CasteletSyntaxTree.WhileExpression:
		var while_block = self._tree.next()

		# Evaluate each condition, then transfer the execution to each
		# condition's associated subroutines
		var eval = _translate_expression(while_block.value.evaluator)
		if eval == true:
			# self._tree = _game_manager.script_trees[while_block.value.subroutine]
			self.load_script(while_block.value.subroutine)
			await load_script_finished
			self._tree.reset()
		
		_game_manager.progress.emit()

	elif next is CasteletSyntaxTree.AssignmentExpression:
		var assignment = self._tree.next()

		# Check if this begins with "default" keyword.
		# If it begins with one, it will only assign the variable
		# when the variable is nonexistent, and won't override
		# existing values
		var is_default = (assignment.lhs.value as String).begins_with("default.")
		if is_default:
			assignment.lhs.value = (assignment.lhs.value as String).trim_prefix("default.")

		var is_persistent = (assignment.lhs.value as String).begins_with("persistent.")
		var varname = assignment.lhs.value
		if is_persistent:
			varname = (assignment.lhs.value as String).trim_prefix("persistent.")
		
		var result = _translate_expression(assignment.rhs)
		var current_var_value = _game_manager.get_variable(varname, is_persistent)

		if (
			assignment is CasteletSyntaxTree.CompoundAssignmentExpression
			and current_var_value != null
		):
			if assignment.compound_operator == "+=":
				current_var_value += result
			elif assignment.compound_operator == "-=":
				current_var_value -= result
			elif assignment.compound_operator == "/=":
				current_var_value /= result
			elif assignment.compound_operator == "*=":
				current_var_value *= result
			elif assignment.compound_operator == "^=":
				current_var_value ^= result
			elif assignment.compound_operator == "%=":
				current_var_value %= result
			_game_manager.set_variable(varname, current_var_value, is_persistent)

		else:
			# Do nothing if default is defined and the variable already had
			# existing value.
			if is_default and current_var_value != null:
				pass
			else:
				_game_manager.set_variable(varname, result, is_persistent)
		
		_game_manager.progress.emit()
	
	elif next is CasteletSyntaxTree.MenuExpression:
		var menu = self._tree.next()
		_show_menu(menu)

	elif next is CasteletSyntaxTree.DialogueExpression:
		var command : CasteletSyntaxTree.DialogueExpression = self._tree.next()
		_update_dialogue(command)
	
	else:
		self._tree.next()


func _translate_expression(expr : CasteletSyntaxTree.BaseExpression):

	var expr_result

	if expr is CasteletSyntaxTree.BinaryExpression:
		expr_result = _process_binary(expr)
	elif expr is CasteletSyntaxTree.VariableExpression:
		var is_persistent = (expr.value as String).begins_with("persistent.")
		var varname = expr.value
		if is_persistent:
			varname = (expr.value as String).trim_prefix("persistent.")

		expr_result = _game_manager.get_variable(varname, is_persistent)
	elif expr is CasteletSyntaxTree.FunctionCallExpression:
		pass #TODO
	else:
		if expr.type == Tokenizer.TOKENS.BOOLEAN:
			if expr.value == "true":
				expr_result = true
			else:
				expr_result = false
		elif expr.type == Tokenizer.TOKENS.NUMBER:
			expr_result = expr.value as float
		else:
			expr_result = expr.value as String
	
	return expr_result


func _process_binary(expr : CasteletSyntaxTree.BinaryExpression):

	var left_hand
	var right_hand
	var op = expr.op

	left_hand = _translate_expression(expr.lhs)
	right_hand = _translate_expression(expr.rhs)

	if (op == "+"):
		return left_hand + right_hand
	elif (op == "-"):
		return left_hand - right_hand
	elif (op == "/"):
		return left_hand / right_hand
	elif (op == "*"):
		return left_hand * right_hand
	elif (op == "%"):
		return left_hand % right_hand
	elif (op == ">"):
		return left_hand > right_hand
	elif (op == ">="):
		return left_hand >= right_hand
	elif (op == "=="):
		return left_hand == right_hand
	elif (op == "<"):
		return left_hand < right_hand
	elif (op == "<="):
		return left_hand <= right_hand
	elif (op == "!="):
		return left_hand != right_hand
	elif (op in ["&&", "and"]):
		return left_hand and right_hand
	elif (op in ["||", "or"]):
		return left_hand or right_hand
	elif (op in ["!", "not"]):
		return not right_hand


func _update_stage_prop(transition : Dictionary = {}):
	var command : CasteletSyntaxTree.StageCommandExpression = self._tree.next()
	var cb = ""

	if command.type == Tokenizer.KEYWORDS.SCENE:
		cb = "scene"
	elif command.type == Tokenizer.KEYWORDS.SHOW:
		cb = "show_prop"
	
	var params = (command.value[0] as String).split(".")
	var prop_func = Callable($SubViewport/CasteletStageNode, cb)

	var args = command.args

	if not transition.is_empty():
		args["transition"] = transition
	
	if len(params) > 1:
		prop_func.call(params[0], params[1], args)
	else:
		prop_func.call(params[0], 'default', args)
	

func _hide_stage_prop(transition = {}):
	var command : CasteletSyntaxTree.StageCommandExpression = self._tree.next()
	var params = (command.value[0] as String).split(".")

	var args = command.args

	if not transition.is_empty():
		args["transition"] = transition
	
	$SubViewport/CasteletStageNode.hide_prop(params[0], args)
	

func _update_transition():
	var command : CasteletSyntaxTree.StageCommandExpression = self._tree.next()

	var transition_name : String = command.value[0]
	var transition_properties : Dictionary = command.args

	if not _game_manager.ffwd_active:

		
		if _transition_manager.transitioning == true:
			_game_manager.set_block_signals(true)
			await _transition_manager.transition_completed
			
			_timer.start()
			await _timer.timeout

			_game_manager.set_block_signals(false)
			

		if _transition_manager.TransitionScope.OBJECT not in _transition_manager.transition_types[transition_name]:
			_transition_manager.transition(transition_name, _transition_manager.TransitionScope.VIEWPORT, transition_properties)
		elif _transition_manager.TransitionScope.VIEWPORT not in _transition_manager.transition_types[transition_name]:
			_transition_manager.transition(transition_name, _transition_manager.TransitionScope.OBJECT, transition_properties)
		else:
			if command.args.has("object") and command.args["object"] == true:
				_transition_manager.transition(transition_name, _transition_manager.TransitionScope.OBJECT, transition_properties)
			else:
				_transition_manager.transition(transition_name, _transition_manager.TransitionScope.VIEWPORT, transition_properties)

	_game_manager.progress.emit()


func _update_audio_channel():
	var command : CasteletSyntaxTree.StageCommandExpression = self._tree.next()
	var channel : String = command.type.to_upper()

	if command.value[0] == "stop":
		_audio_manager.stop_audio(channel)
	elif command.value[0] == "pause":
		_audio_manager.pause_audio(channel)
	elif command.value[0] == "resume":
		_audio_manager.resume_audio(channel)
	elif command.value[0] == "":
		_audio_manager.refresh_audio(command.args, channel)
	else:
		if len(command.value) > 1:
			_audio_manager.queue_audio(command.value, command.args, channel)
		else:
			_audio_manager.play_audio(command.value[0], command.args, channel)
	
	_game_manager.progress.emit()
	

func _update_window():
	var command : CasteletSyntaxTree.StageCommandExpression = self._tree.next()

	if command.value[0] in ["show", "on"]:
		$SubViewport/CasteletGUINode.show_window()
	elif command.value[0] in ["hide", "off"]:
		$SubViewport/CasteletGUINode.hide_window()


func _update_dialogue(command : CasteletSyntaxTree.DialogueExpression):
	
	if _transition_manager.transitioning == true:
		_game_manager.set_block_signals(true)
		await _transition_manager.transition_completed
		_game_manager.set_block_signals(false)
	
	var dialogue = {
		"speaker": command.speaker,
		"dialogue" : command.dialogue,
		"args" : command.args,
	}

	# Read if any variables/values to be interpolated exist
	var formatter = []
	for vr in dialogue["args"]["formatter"]:
		var val;
		print(vr)
		if vr.type == Tokenizer.TOKENS.SYMBOL:
			if vr.value.begins_with("persistent."):
				val = _game_manager.get_variable(vr.value.trim_prefix("persistent."), true)
			else:
				val = _game_manager.get_variable(vr.value)
		else:
			val = vr.value
		if vr.type == Tokenizer.TOKENS.NUMBER:
			val = val as float
		elif vr.type == Tokenizer.TOKENS.BOOLEAN:
			if val == "true":
				val = true
			else:
				val = false
		else:
			pass
		formatter.append(val)
	dialogue["dialogue"] = dialogue["dialogue"] % formatter

	# Lastly, extract custom tags such as wait [w] and auto-dismiss [nw].
	# They're not meant to be custom BBCodes and can interfere with other
	# functionalities those don't need them (e.g. dialogue history), so
	# we extract them here and store it into the expression instead.
	var dialogue_processed : Dictionary = dialogue_tools.extract_custom_non_bbcode_tags(dialogue["dialogue"])
	for arg in dialogue_processed["args"].keys():
		dialogue["args"][arg] = dialogue_processed["args"][arg]
	dialogue["dialogue"] = dialogue_processed["dialogue"]
	
	# If the speaker data starts with "id_", make sure to check the assets database
	# for the proper speaker name.
	if command.speaker.begins_with("id_"):
		if not (_assets_manager.props.has(command.speaker.trim_prefix("id_"))):
			push_warning("The defined prop does not actually exist." +
				" Temporarily assigning prop ID as speaker label.")
			dialogue["speaker"] = command.speaker.trim_prefix("id_")
		else:
			dialogue["speaker"] = _assets_manager.props[command.speaker
									.trim_prefix("id_")].prop_name
	
	$SubViewport/CasteletGUINode.update_dialogue(dialogue)

	# Append current dialogue to the seen-dialogue cache
	if command.speaker != "extend":
		_game_manager.append_dialogue(dialogue)
	else:
		_game_manager.append_dialogue_extend(dialogue)


func _on_end_of_script():
	print_debug("End of script reached")


# Only progress when not paused.
# (Requires more testing with multiple scenes active)
func _on_progress():
	if not _paused:
		if not self._tree.is_at_end():
			_next()
		else:
			end_of_script.emit()


func play_scene(from_beginning = true):
	_mutex.lock()
	while not _can_play:
		pass
	
	if from_beginning:
		_tree.reset()
	_paused = false
	_mutex.unlock()

	_next()


func pause_scene():
	_mutex.lock()
	_paused = true
	_mutex.unlock()


func stop_scene():
	_mutex.lock()
	_tree.reset()
	_mutex.unlock()


func _show_menu(menu : CasteletSyntaxTree.MenuExpression):
	
	_game_manager.menu_showing = true

	if not _config_manager.get_config(_config_manager.ConfigList.CONTINUE_FFWD_ON_CHOICE):
		_game_manager.ffwd_active = false
	
	# _game_manager.auto_active = false

	# _game_manager.set_block_signals(true)

	if menu.value != null:
		_update_dialogue(menu.value)

	var choices = []
	for choice in menu.choices:
		choices.append({
				"choice" : choice.value,
				"sub" : choice.subroutine,
				"condition" : _translate_expression(choice.condition),
		})

	$SubViewport/CasteletGUINode.show_choices(choices)

	var next_tree = await $SubViewport/CasteletGUINode.choice_made
	print_debug(next_tree)

	self.load_script(next_tree)
	await load_script_finished
	self._tree.reset()

	# _game_manager.set_block_signals(false)

	_game_manager.menu_showing = false
	_game_manager.progress.emit()


# Terminates this node. Intended to be called externally.
func end():

	# Make sure the persistent data is saved upon terminating the theater
	# player
	_state_manager.save_persistent()
	
	stop_scene()

	_transition_manager.vp = null
	remove_child(_timer)
	_timer.queue_free()

	# Ensures the signal handler is disconnected before this node is destroyed, just in case.
	_game_manager.progress.disconnect(_on_progress)
	end_of_script.disconnect(_on_end_of_script)

	$SubViewport/CasteletStageNode.hide()
	$SubViewport/CasteletGUINode.hide()
	
	queue_free()
	

func _exit_tree() -> void:
	_ending_thread = true
	_semaphore.post()
	_thread.wait_to_finish()
